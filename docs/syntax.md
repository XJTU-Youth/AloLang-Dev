# Alolang语言参考

## 词法约定

本节介绍 Alolang 程序的基本元素。 你将使用这些名为“词法元素”或“标记”的元素构造用于构造完整程序的语句、定义和声明等。 本节将讨论以下词法元素：

### 标记和字符集

程序的文本由标记和空格组成。 Alolang 标记是对编译器有用的 Alolang  程序的最小元素。Alolang 分析器识别以下类型的标记：

-关键字
-标识符
-数值、布尔和指针文本
-字符串和字符文本
-用户定义的文本
-运算符
-标点符号

标记通常由空格分隔，可以是一个或多个：

-空白
-水平或垂直制表符
-新行
-换源
-注释

#### 基本源字符集

C++标准指定可用于源文件的基本源字符集。 若要表示这组字符之外的字符，可以通过使用通用字符名称指定其他字符。 基本源字符集由可在源文件中使用的96个字符组成。 这组字符包括空白字符、水平制表符、垂直制表符、换页符和换行控制字符以及这一组图形字符：

```Alolang

a b c d e f g h i j k l m n o p q r s t u v w x y z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

0 1 2 3 4 5 6 7 8 9

_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " '

```

#### 通用字符名称

由于 Alolang 程序可使用的字符要比在基本源字符集中指定的字符要多得多，所以可以通过使用 通用字符名称以可移植的方式指定这些字符。 通用字符名称由表示 Unicode 码位的字符序列组成。 采用两种形式。 使用 \UNNNNNNNN 表示形式为 U+NNNNNNNN 的 Unicode 码位，其中 NNNNNNNN 是八位的十六进制码位数字。 使用四位的 \uNNNN 表示形式为 U+0000NNNN 的 Unicode 码位。

通用字符名称可用于标识符、字符串和字符文本中。 通用字符名称不能用于表示范围 0xD800-0xDFFF 之内的代理项码位。 而应使用所需的码位；编译器会自动生成任何必需的代理项。 其他限制适用于可在标识符中使用的通用字符名称。 有关详细信息，请参阅 Identifiers 和 String and Character Literals。\

#### 执行字符集

执行字符集表示可以出现在编译的程序中的字符和字符串。 这些字符集包含源文件中允许的所有字符，还包含表示警报、backspace、回车符和 null 字符的控制字符。 执行字符集具有特定于区域设置的表示形式。

### 注释

注释是编译器忽略但对于程序员非常有用的文本。 注释通常用于批注代码以供将来参考。 编译器会将它们视为空白。 您可以使用测试中的注释来使某些代码行处于非活动状态;但是，#if/#endif 预处理器指令的工作效果更好，因为你可以包围包含注释的代码，但不能嵌套注释。

通过以下方式之一是编写 Alolang 注释：

/\* （斜杠，星号）字符，后跟任何字符序列（包括新行），后跟 \*/ 个字符。

// （两个斜杠）字符，后跟任何字符序列。 不紧跟在反斜杠之前的新行会终止这种形式的注释。 因此，它通常称为 "单行注释"。

注释字符（`/*`、`*/`和`//`）在字符常量、字符串文本或注释中没有特殊含义。 使用第一个语法的注释无法嵌套。

### 标识符

标识符是用于表示以下内容之一的字符序列：

-对象或变量名称
-类或联合名称
-枚举类型名称
-类、联合或枚举的成员
-函数或类成员函数
-typedef 名称
-标签名称
-宏名称
-宏参数

允许将以下字符用作标识符的任意字符：

``` alolang
_ a b c d e f g h i j k l m
n o p q r s t u v w x y z
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z
```

允许将以下字符用作标识符中除第一个字符以外的任意字符：

``` alolang
0 1 2 3 4 5 6 7 8 9
```

标识符的第一个字符必须是字母字符（大写、小写或带下划线 ( _ ) 的字母）。 由于 Alolang 标识符区分大小写，因此 fileName 与 FileName不同。

标识符不能与关键字有完全相同的拼写和大小写。 包含关键字的标识符是合法的。 例如，Pint是一个合法标识符，即使它包含int，这是一个关键字。

使用两个顺序下划线字符 ( __ ) 在一个标识符或在单个前导下划线后跟一个大写字母，将保留用于C++中的所有作用域的实现。 由于当前或将来的保留标识符可能发生冲突，因此应避免对文件范围的名称使用一个前导下划线后跟小写字母。

### 关键字

关键字是具有特殊意义的预定义保留标识符。 它们不能用作程序中的标识符。

Alolang 保留了下列关键字。

``` alolang
begin    bool
break    case    catch    char    const    delete    continue    do    double    else    enum    end
extern    false    finally    float    for    friend    goto    if    inline    int    input    long    new
operator   output    sizeof    static    struct    switch    template    this    throw    true    try    typedef
typeid    typename    union    virtual    void    volatile    while    __cpp__
```

### 标点符号

在 Alolang 中，标点符号相对于编译器来说具有语法意义和语义含义，但是它们本身不会指定一个产生数值的操作。 某些标点符号（单独或组合）也可以是 Alolang 运算符或对预处理器很重要。
以下任意字符都被视为标点符号：

``` alolang
! % ^ & * ( ) - + = { } | ~
[ ] \ ; ' : " < > ? , . / #
```

标点符号 [] 、 （） 和 {} 必须成对出现。

### 数值、布尔文本

文本是一种直接表示值的程序元素。文本的最常用法是初始化命名变量以及将自变量传递给函数。

有时需要指示编译器如何解释某个文本或者为其赋予哪种特定类型。 你可以通过为文本追加前缀或后缀来达到此目的。 例如，前缀 0x 指示编译器将其后面的数字解释为十六进制值，例如 0x35。 U) 后缀通知编译器将值视为无符号长整型类型，如5894345ULL 中所示。 有关每个文本类型的前缀和后缀的完整列表，请参阅以下各节。

#### 整数文本

整数文本以数字开头，没有小数部分或指数。 你可以指定十进制、八进制或十六进制形式的整数文本。 它们可指定有符号类型或无符号类型以及长类型或短类型。
如果不存在前缀或后缀，则编译器将提供整型文本值类型int （64位）（如果值适合），否则它会将其类型指定为长整型（任意位）。

要指定十进制整型文本，请以非零数字作为规范的开头。要指定八进制整型文本，请以 0 作为规范的开头，后跟 0 到 7 之间的一系列数字。 在指定八进制文本时，使用数字 8 和 9 是错误做法。 要指定十六进制整型文本，请以 0x 或 0X 作为规范的开头（“x”的大小写形式并不重要），后跟 0 到 9 以及 a（或 A）到 f（或 F）之间的一系列数字。 十六进制数字 a（或 A）到 f（或 F）表示介于 10 和 15 之间的值。若要指定 long 类型，请使用 l 或 L 后缀。

数字分隔符：可以使用单引号字符（撇号）将位置值隔开，使其更易于阅读。 分隔符不会对编译产生任何影响。

#### 浮点文本

浮点文本指定必须具有小数部分的值。 这些值包含小数点（ . ），并且可包含指数。

浮点文本具有“尾数”（用于指定数字的值）、“指数”（用于指定数字的量级）和可选的后缀（用于指定文本的类型）。 指定的尾数的格式是一系列位数后跟一个句点，再后跟表示数字的小数部分的可选的一系列位数。

指数（如果有）指定数字的量级为 10 次幂，如以下示例所示：

指数可以使用 e 或 E来指定，它们具有相同的含义，后跟一个可选符号（+ 或-）和一系列数字。 如果指数存在，则整数（如 18E0）中不需要尾随的小数点。
浮点文本默认为double类型。

#### 布尔值文本

布尔值文本为true和false。

### 字符串和字符文本

#### 字符串文本

由一个或几个字符常量构成。 它由用双引号引起来的字符串表示。

#### 字符文本

由一个字符常量构成。 它由用单引号引起来的字符表示。用于字符文本的字符可以是除保留字符反斜杠（"\"）、单引号（'）或换行符之外的任何字符。 可以使用转义序列指定保留字符。 可以通过使用通用字符名称指定字符，只要类型的大小足以保留字符。

##### 编码

字符文本根据其前缀以不同的方式进行编码。

不带前缀的字符文本是普通字符文本。 包含可在执行字符集中表示的单个字符、转义序列或通用字符名称的普通字符文本值具有等于其编码在执行字符集中的数值的值。 包含多个字符、转义序列或通用字符名称的普通字符文本是一个多字符文本。 不能用执行字符集表示的多字符文本或普通字符文本的类型为int，其值是实现定义的。

以 L 前缀开头的字符文本是宽字符文本。 包含单个字符、转义序列或通用字符名称的宽字符文本的值的值等于其在执行宽字符集中的编码的数值，除非字符文本在执行宽字符集，在这种情况下，该值是实现定义的。 包含多个字符、转义序列或通用字符名称的宽字符文本的值是实现定义的。 有关 MSVC，请参阅下面的Microsoft 特定部分。

以 u8 前缀开头的字符文本是 UTF-8 字符文本。 如果 UTF-8 字符文本包含一个字符、转义序列或通用字符名称，则其值等于其 ISO 10646 码位值（如果可由单个 UTF-8 代码单元表示（对应于 C0 控件和基本拉丁语）Unicode 块）。 如果值不能由单个 UTF-8 代码单元表示，则程序格式不正确。 包含多个字符、转义序列或通用字符名称的 UTF-8 字符文本格式错误。

以 u 前缀开头的字符文本是 UTF-16 字符文本。 如果 UTF-16 字符文本包含一个字符、转义序列或通用字符名称，则其值等于其 ISO 10646 码位值（如果它可由单个 UTF-16 代码单元表示（对应于基本多语言平面）). 如果值不能由单个 UTF-16 代码单元表示，则程序格式不正确。 包含多个字符、转义序列或通用字符名称的 UTF-16 字符文本格式错误。

以 U 前缀开头的字符文本是一个32字符文本。 包含一个字符、转义序列或通用字符名称的 UTF-32 字符文本的值的值等于其 ISO 10646 代码点值。 包含多个字符、转义序列或通用字符名称的32字符串格式不正确。

### 用户定义的文本

## 基本概念

## 内置类型

内置类型（也称为基本类型）由Alolang语言标准指定，并内置于编译器。 不会在任何标头文件中定义内置类型。

AloLang的所有类型和函数的默认链接性为内部链接，意为只在定义的文件内可见

Alolang的内置类型包括如下所有类型及其引用

使用cv标识符表示变量存储特征

函数本身也被认为是一类类型

### 基本数据类型

|名称        |关键字  |说明                |
|-----------|-------|--------------------|
|字符        |char  |应支持所有Unicode字符  |
|整数        |int   |64位整型              |
|高精整数    |long  |无限精度整数           |
|双精度浮点数 |double|                     |
|实数        |real  |可表示所有分数    待定 |
|布尔值      |bool  |                     |

### 复合数据类型

|名称        |关键字  |说明                              |
|-----------|-------|----------------------------------|
|字符串      |string |要求同char                         |
|数组        |array  |一组相同类型的数据，可嵌套，定长       |
|变长数组    |vlarray|可变长度数组                        |
|栈         |stack  |FILO数据组合                        |
|队列        |queue  |FIFO数据组合                       |
|链表        |list   |同STL的list                        |
|元组        |tuple  |由固定个数不一定相同类型的数据组成的结构|
|对          |pair   |成员数量限制为2的tuple              |
|复数        |complex|由两个real或double组成的结构，表示复数|
|四元数      |quaternion|类似complex实现的四元数          |
|矩阵        |mat    |由double组成的矩阵，支持矩阵运算      |
|向量        |vector |数学向量，使用double存储，支持向量运算 |

## 声明和定义以及赋值

任何变量和函数都必须在出现之前进行声明，并在实际使用之前进行定义。

变量和函数在一个文件内仅能进行一次声明和一次定义。

变量声明语句如下：

``` alolang
[extern] [cv] type_name variant_name;
```

变量定义语句如下：

``` alolang
variant_name = value;
```

变量的声明和定义也可在同一行内完成：

``` alolang
[extern] [cv] type_name variant_name = value;
```

非函数的非const变量也可重复赋值，与定义语句形式相同

## 编译器预处理指令

实际编译之前编译器预处理器会对代码进行预处理。使用编译器预处理指令指明要进行的处理

编译器预处理指令每条指令独占一行，以`%`开头。结尾没有分号，没有缩进

以`%`开头的行是且仅是预处理器指令

预处理器指令与参数之间有且只有一个空格。行尾没有空格

预处理指令及其含义如下：

### `%def`

定义编译器预处理常量

实现为宏替换

不支持定义宏函数

用法：

``` alolang
%def NAME VALUE
```

也可定义没有值的常量

``` alolang
%def NAME
```

### `%ifndef`以及`%ifdef`

### `%endif`

### `%rmdef`

### `%lib`

说明库名称，无实际作用

### `%import`

导入AloLang库文件

用法：

``` alolang
%import path_to_lib
```

预处理时实际采用库文件的内容替换该行指令

## 内置运算符、优先级和关联性

### 内置运算符的优先级和关联性同C

### 加法运算符：`+` 和 `-`

相加运算符采用算术或指针类型的操作数。 加法（ `+` ）运算符的结果是操作数之和。 减法（ `-` ）运算符的结果是操作数之差。

### 赋值运算符

简单赋值 `=` 表示将右边的值赋给左边。

复合赋值  `*=`   `/=`   `%=`   `+=`   `-=`   `<<=`   `>>=`   `&=`   `^=`   `|=`  表示将左值与右值进行运算并将结果赋给左边。

赋值运算符返回右值。

### 逻辑 AND 运算符： `&&`

如果两个操作数都为 TRUE，则逻辑 "与" 运算符（ `&&` ）返回布尔值 `true`，否则返回 `false`。 操作数在计算前隐式转换为bool类型，结果为bool类型。

### 逻辑 OR 运算符：`||`

如果两个操作数都为 TRUE，则逻辑 OR 运算符（ `||` ）返回布尔值 `true`，否则返回 `false`。 操作数在计算前隐式转换为bool类型，结果为bool类型。

### 逻辑非运算符：`!`

逻辑求反运算符（ `!` ）反转操作数的含义。 操作数必须是算法或指针类型（或计算结果为算法或指针类型的表达式）。 操作数隐式转换为bool类型。 如果转换后的操作数为 FALSE，则结果为 TRUE;如果转换后的操作数为 TRUE，则结果为 FALSE。 结果的类型为bool。

### 位运算符 `^`  `|`  `&`

分别表示按位异或，按位或，按位与。

两边操作数将被逐位实施异或，或，与。

### 相等运算符 `==`  `!=`

 `==` 左右若相等，返回`true`,反之返回`false`。!=正好相反。

### 关系运算符： `<`、`>`、`<=` 和 `>=`

若所描述的数学命题为真，返回`true`,反之返回`false`。

### 逗号运算符

从左到右依次计算每个表达式，返回一个元组。

### 左移和右移运算符 ( `<<` 和 `>>` )

运算符左边的数每一个位都向指定方向移动指定位。空位填充0。出界位消失。

## 表达式

表达式是用于实现以下一个或多个目的而使用的运算符和操作数的序列：

-计算来自操作数的值。
-指定对象或函数。
-生成“副作用”。 （副作用是表达式的计算之外的所有操作 - 例如，修改对象的值。）

表达式根据其运算符的优先级和分组来计算。

## 语句

Alolang 语句将按顺序执行，除非表达式语句、选择语句、迭代语句或跳转语句特意修改了顺序。

### IO语句

IO语句有两种：输入语句和输出语句。

#### 输入语句

输入语句使用`input ... from ...`关键字标识。它的基本使用方法为：

```alolang
input variable from source;
```

其中`variable`为写入变量，`source`为数据来源文件的绝对路径或者`-`，当`source`为`stdin`的时候采用标准输入流进行输入，
否则采用指定文件进行输入。

#### 输出语句

输入语句使用`output ... to ...`关键字标识。它的基本使用方法为：

```alolang
output variable from destination;
```

其中`variable`为要输出的变量，destination为数据目的输出文件的绝对路径或者`stdout`或者`stderr`，当`destination`为`-`的时候采用标准输出流进行输出，
当`destination`为`stderr`是采用标准错误流进行输出，否则采用指定文件进行输出。

### 标记语句

标签用于将程序控制权直接转交给特定语句。标记语句使用冒号将某种标签与语句隔开。这种标签满足标识符的要求。

只有goto语句可以将程序转到标签处运行。而这是不推荐使用的。

标签具有函数范围，并且不能在函数中重新声明。 但是，相同的名称可用作不同函数中的标签。

### 表达式语句

表达式语句导致计算表达式。 出于表达式语句的原因，不会发生控制或迭代的传输。

表达式语句的语法就是

`[expression ] ;`

在执行下一个语句前，将计算表达式语句中的所有表达式并完成所有副作用。 最常用的表达式语句是赋值和函数调用。 由于表达式是可选的，因此分号单独被视为空的表达式语句，称为null语句。

### 复合语句

复合语句由零个或多个括在大括号（ `{}` ）中的语句组成。 可以在任何期望语句出现的位置使用复合语句。

在Alolang中，也可以使用这样的语法

```Alolang
begin [descriptions]:
[statement list]
end [descriptions];
```

其中description是对内容的描述，没有作用，是可选的。但是上下两处必须相同。

### 选择语句

#### if-else 语句

```Alolang
if ( expression )
{
   statement1;
   ...
}
else  // optional
{
   statement2;
   ...
}
```

表示如果expression为真，则执行statement1...而不执行statement2...。否则执行statement2...，而不执行statement1...。

#### switch语句

```Alolang
switch ( init; expression )
   case constant-expression : statement
   [default  : statement]
```

表示若expression的值等于constant-expression，则跳转到这行执行。若不等于任何一个，则跳转到default执行。

### 迭代语句

#### While 语句

```Alolang
while ( expression )
   statement
```

表示重复执行语句，直到expression的计算结果为零。

表达式的测试在每次执行循环之前发生;因此， while循环将执行零次或多次。 表达式的类型必须可以明确转换为整型。

#### do-while 语句

```Alolang
do
   statement
while ( expression ) ;
```

表示重复执行语句，直到expression的计算结果为零。

终止条件的测试在每次执行循环之后进行;因此， do循环会执行一次或多次，具体取决于终止表达式的值。表达式的类型必须可以明确转换为整型。

#### for语句

```Alolang
for ( init-expression ; cond-expression ; loop-expression )
    statement;
```

重复执行语句，直到条件变为 false。

### 跳转语句

####　break 语句

`break;`

用于结束执行最近的封闭循环或它所在的条件语句。 控制权将传递给该语句结束之后的语句（如果有的话）。

#### continue语句

`continue;`

强制将控制传输到最小封闭do、 for或while循环的控制表达式。

#### return 语句

`return [expression];`

终止函数的执行并返回对调用函数的控制（或对操作系统的控制，如果您从 main 函数转移控制）。 紧接在调用之后在调用函数中恢复执行。

#### goto语句

`goto identifier;`

Goto语句无条件将控制转移到由指定的标识符标记的语句。

<!--# 命名空间-->

## 枚举

枚举是用户定义的类型，其中包含一组称为枚举器的命名的整型常数。

## Unions

联合是用户定义的类型，其中的所有成员共享相同的内存位置。 这意味着在任何给定时间，联合都不能包含来自其成员列表的多个对象。 这还意味着无论联合具有多少成员，它始终仅使用足以存储最大成员的内存。

具有大量对象和/或内存有限时，联合可用于节省内存。 但是，需要格外小心才能正确使用它们，因为由你负责确保可始终访问写入的最后一个成员。 如果任何成员类型具有不常用构造函数，则必须编写附加代码来显式构造和销毁该成员。

`union [name]  { member-list };`

## 函数

函数是执行某种操作的代码块。 函数可以选择性地定义使调用方可以将实参传递到函数中的输入形参。 函数可以选择性地返回值作为输出。 函数可用于在单个可重用块中封装常用操作（理想情况是使用可清晰地描述函数行为的名称）。 以下函数接受来自调用方的两个整数并以相反顺序返回它们。

```Alolang
fun foobar(long a, int b) ->int, long
{
return b,a;
}
```

可以在程序中的任意位置调用或调用函数。 传递给函数的值是参数，其类型必须与函数定义中的参数类型兼容。

对于函数长度没有实际限制，不过良好的设计应以执行单个明确定义的任务的函数为目标。 复杂算法应尽可能分解成易于理解的更简单函数。

最小函数声明包括返回类型、函数名和参数列表（可能为空），以及提供编译器附加说明的可选关键字。 下面的示例是一个函数声明：

```Alolang
fun foobar(long a, int b) ->int, long;
```

函数定义包含声明和主体，主体是大括号之间的所有代码：

```Alolang
fun foobar(long a, int b) ->int, long;
{
return b,a;
}
```

后接分号的函数声明可以出现在程序中的多个位置处。 它必须在每个翻译单元中对该函数的任何调用之前出现。 根据单个定义规则 (ODR)，函数定义必须仅在程序中出现一次。

函数声明的必需部分有：

返回类型，该类型指定函数返回的值的类型; 如果没有返回值，则为`void` 。

函数名，必须以字母或下划线开头，不能包含空格。 一般而言，标准库函数名中的前导下划线指示私有成员函数，或不是供你的代码使用的非成员函数。

参数列表（一组用大括号限定、逗号分隔的零个或多个参数），指定类型以及可以用于在函数体内访问值的可选局部变量名。

函数声明的可选部分有：

`constexpr`，指示函数的返回值是常量值，可以在编译时进行计算。

```Alolang
constexpr fun exp(float x, int n) ->float
{
    return n == 0 ? 1 :
        n % 2 == 0 ? exp(x * x, n / 2) :
        exp(x * x, (n - 1) / 2) * x;
};
```

链接规范： extern或静态。

```Alolang
//Declare printf with C linkage.
extern fun foobar(long a, int b) ->int, long
```

inline，指示编译器将对函数的每个调用替换为函数代码本身。 在某个函数快速执行并且在性能关键代码段中重复调用的情况下，内联可以帮助提高性能。

```Alolang
inline fun foobar(long a, int b) ->int, long
{
return b,a;
}
```

一个` noexcept `表达式，指定函数是否会引发异常。 在下面的示例中，如果 is_pod 表达式的计算结果为true，则函数不引发异常。

```Alolang

#include <type_traits>

template <typename T>
fun copy_object(T& obj) noexcept(std::is_pod<T>) ->T
{...}
```

（仅限成员函数）Cv 限定符，用于指定函数是const函数还是volatile函数。

（仅限成员函数）虚拟、override或 final。 virtual指定可以在派生类中重写函数。 override 表示派生类中的函数在重写虚函数。 final 表示函数不能在任何进一步的派生类中进行重写。

（仅限成员函数）应用于成员函数的静态意味着该函数不与类的任何对象实例相关联。

（仅限非静态成员函数）引用限定符，用于指定编译器在隐式对象参数是右值引用与左值引用时，要选择的函数的重载。

## 重载

当几个函数有重合的作用域，名称相同，但拥有不同参数表时，视为不同的函数，调用时根据赋予的参数决定实际调用哪一个。这种行为称作函数的重载。

### 运算符重载

与函数相似，运算符也可以被重载。

以下规则约束如何实现重载运算符。 但是，它们不适用于新的和删除的运算符，它们分别涉及到：

-不能定义新运算符
-将运算符应用于内置数据类型时，不能重新定义其含义。
-运算符遵循它们通常用于内置类型时指定的操作数的优先级、分组和数量。
-如果运算符可用作一元运算符或二元运算符（ & 、 * 、 + 和 - ），则可以单独重载每个使用。
-重载运算符不能具有默认自变量。
-派生类继承除赋值（operator = ）以外的所有重载运算符。
-成员函数重载运算符的第一个自变量始终属于针对其调用运算符的对象的类类型（从中声明运算符的类或派生自该类的类）。 没有为第一个参数提供转换。
-当运算符作为全局函数重载，它有数量等同于它操作数个数的参数表。当运算符作为成员函数重载，它有数量比它操作数个数少1的参数表，这是因为调用它的对象被认为是一个操作数。

以下是一些例子：

```Alolang
fun operator+(const &Box)->Box;
```

```Alolang
fun operator <(const Distance& d)->bool;
```

```Alolang
friend fun &operator<<( ostream &output, const Distance &D )->ostream
      {
         output << "F : " << D.feet << " I : " << D.inches;
         return output;
      }
```

```Alolang
fun operator++ ()->Time  ;\\前置递增
```

```Alolang
fun operator++ (int)->Time  ;\\后置递增
```

## 类

类是用于定义你自己的类型的构造。 类都可以包含数据成员和成员函数，使你可以描述类型的状态和行为。

### 类的声明

```Alolang
[template-spec]
class [tag [: base-list ]]
{
   member-list
} [declarators];
[ class ] tag declarators;
```

其中[tag [: base-list ]]描述类的继承来源。

### 类的成员

#### 成员访问控制

##### public

在类成员列表前面时， public关键字指定可以从任何函数访问这些成员。 这适用于声明到下一个访问指示符或类的末尾的所有成员。

在基类的名称前面时， public关键字指定基类的公共成员和受保护成员分别是派生类的公共和受保护成员。

##### private

在类成员列表前面时， private关键字指定只能从类的成员函数和友元访问这些成员。 这适用于声明到下一个访问指示符或类的末尾的所有成员。

在基类的名称前面时， private关键字指定基类的公共成员和受保护成员是派生类的私有成员。

##### protected

Protected关键字指定对成员列表中的类成员的访问，直到下一个访问说明符（public或private）或类定义的末尾。 声明为protected的类成员仅可用于以下项：

-最初声明这些成员的类的成员函数。
-最初声明这些成员的类的友元。
-使用公共或受保护访问（派生自最初声明这些成员的类）派生的类。
-也对受保护成员具有专用访问权限的以私有方式派生的直接类。

在基类的名称前面时， protected关键字指定基类的公共成员和受保护成员都是其派生类的受保护成员。

##### 友元

在某些情况下，可以更方便地对不是类成员的函数或单独类中的所有成员授予成员级访问权限。 仅类实现器可以声明其友元。 函数或类不能将其自身声明为任何类的友元。 在类定义中，使用friend关键字和非成员函数或其他类的名称向其授予对类的私有和受保护成员的访问权限。 在模板定义中，可以将类型参数声明为友元。

```Alolang
friend F;
```

用于已经声明的F。

```Alolang
class friend F;
```

用于未声明的F。

#### 特殊成员函数

##### 构造函数

若要自定义类成员的初始化方式，或在创建类的对象时调用函数，请定义构造函数。 构造函数具有与类相同的名称，没有返回值。 你可以根据需要定义任意多个重载构造函数，以各种方式自定义初始化。 通常，构造函数具有公共可访问性，以便类定义或继承层次结构外的代码可以创建类的对象。 但也可以将构造函数声明为受保护或私有。

```Alolang
fun classname(paralist);
```

###### 成员初始值设定项列表

构造函数可以选择具有成员初始值设定项列表，该列表在执行构造函数正文之前初始化类成员。

首选使用成员初始值设定项列表，而不是在构造函数的主体中赋值，因为它直接初始化成员。 在下面的示例中，成员初始值设定项列表由冒号后面的所有标识符（自变量） 表达式组成：

```Alolang
    fun Box(int width, int length, int height)
        : m_width(width), m_length(length), m_height(height)
    {}
```

##### 默认构造函数

默认构造函数通常没有参数，但它们可以包含具有默认值的参数。

默认构造函数是一种特殊的成员函数。 如果未在类中声明任何构造函数，则编译器将提供隐式内联默认构造函数。

如果声明了任何非默认构造函数，编译器不会提供默认构造函数

```Alolang
class myclass{};
fun main()->int
{
myclass mc();     // warning C4930: prototyped function not called (was a variable definition intended?)
}
```

注意，以上示例表达式既可以解释为函数的声明，也可以解释为对默认构造函数的调用，而且 C++ 分析器更偏向于声明，因此表达式会被视为函数声明。

##### 复制构造函数、

复制构造函数通过从同一类型的对象复制成员值来初始化对象。 如果类成员是所有简单类型（如标量值），则编译器生成的复制构造函数便已足够，无需自行定义。 如果你的类需要更复杂的初始化，则需要实现自定义复制构造函数。 例如，如果类成员是一个指针，则需要定义一个复制构造函数以分配新内存并从另一个指向对象复制值。 编译器生成的复制构造函数只复制指针，使新指针仍指向另一个内存位置。

##### 委托构造函数

```Alolang
class class_c {
public:
    int max;
    int min;
    int middle;

    fun class_c(int my_max) {
        max = my_max > 0 ? my_max : 10;
    }
    fun class_c(int my_max, int my_min) : class_c(my_max) {
        min = my_min > 0 && my_min < max ? my_min : 1;
    }
    fun class_c(int my_max, int my_min, int my_middle) : class_c (my_max, my_min){
        middle = my_middle < max && my_middle > min ? my_middle : 5;
}
};
fun main()->int
{

    class_c c1{ 1, 3, 2 };
}
```

当您单步调试上一示例时，请注意，构造函数fun class_c(int, int, int) 首先调用构造函数fun class_c(int, int)，该构造函数反过来调用fun class_c(int)。 每个构造函数将仅执行其他构造函数不会执行的工作。

#### 析构函数

析构函数是一个成员函数, 该函数在对象超出范围时自动调用, 或通过调用delete进行显式销毁。 析构函数具有与类相同的名称, 前面有一个波形符 (~)。 例如，声明 String 类的析构函数：

```Alolang
fun ~String()。
```

析构函数声明的规则：

-不接受自变量。
-不返回值 (或void)。
-不能声明为const、 volatile或static。 但是, 可以调用它们来销毁声明为const、 volatile或static的对象。
-可以声明为虚拟。 通过使用虚拟析构函数，无需知道对象的类型即可销毁对象 - 使用虚函数机制调用该对象的正确析构函数。 请注意，析构函数也可以声明为抽象类的纯虚函数。

当下列事件之一发生时，将调用析构函数：

-具有块范围的本地（自动）对象超出范围。
-使用new运算符分配的对象使用delete进行显式释放。
-临时对象的生存期结束。
-程序结束，并且存在全局或静态对象。
-使用析构函数的完全限定名显式调用了析构函数。

析构函数可以随意调用类成员函数和访问类成员数据。

对析构函数的使用有两个限制:

-不能采用其地址。
-派生类不继承其基类的析构函数。

##### 析构的顺序

当对象超出范围或被删除时，其完整析构中的事件序列如下所示：

-将调用该类的析构函数，并且会执行该析构函数的主体。
-按照非静态成员对象的析构函数在类声明中的显示顺序的相反顺序调用这些函数。 构造这些成员时使用的可选成员初始化列表不会影响构造或析构的顺序。
-非虚拟基类的析构函数以声明的相反顺序调用。
-虚拟基类的析构函数以声明的相反顺序被调用。

### 继承

可以使用名为 "继承" 的机制从现有类派生新类（请参阅以单一继承开始的信息）。 用于派生的类称为特定派生类的“基类”。 使用以下语法声明派生类：

```Alolang
class Derived : [virtual] [access-specifier] Base
{
   // member list
};
class Derived : [virtual] [access-specifier] Base1,
   [virtual] [access-specifier] Base2, . . .
{
   // member list
};
```

在类的标记（名称）后面，显示了一个后跟基本规范列表的冒号。 以这种方式命名的基类必须已提前声明。 基本规范可能包含访问说明符，该说明符是公共、受保护或私有关键字之一。 这些访问说明符显示在基类名称的前面并且仅适用于该基类。 这些说明符控制要对基类的成员使用的派生类的权限。 如果省略访问说明符，则会将对该基的访问视为私有。 基本规范可能包含关键字virtual来指示虚拟继承。 此关键字可能出现在访问说明符前面或后面（如果有）。 如果使用虚拟继承，则基类称为虚拟基类。

一个类可以从多个基类派生，基类之间用逗号连接。

#### 虚函数

虚函数是应在派生类中重新定义的成员函数。 当使用指针或对基类的引用来引用派生的类对象时，可以为该对象调用虚函数并执行该函数的派生类版本。
虚函数确保为该对象调用正确的函数，这与用于进行函数调用的表达式无关。

## 引用

引用将存储位于内存中其他位置的对象的地址。 与指针不同的是，初始化之后的引用无法引用不同的对象或设置为 null。 有两种类型的引用：引用命名变量的 lvalue 引用和引用临时对象的 rvalue 引用。 & 运算符表示左值引用，&& 运算符表示右值引用，或基于上下文的通用引用。

```Alolang
int &i;
char &i, &j;
```

引用和对象可以一起声明：

```Alolang
int &ref, k;
```

引用保留对象的地址，但语法行为与对象一样。

### 左值引用&

存储对左值的引用。

### 右值引用&&

存储对右值的引用。

### 引用类型函数自变量

向函数传递引用而非大型对象的效率通常更高。 这使编译器能够在保持已用于访问对象的语法的同时传递对象的地址。

### 引用类型函数返回

可将函数声明为返回引用类型。 做出此类声明有两个原因：

返回的信息是一个返回引用比返回副本更有效的足够大的对象。
函数的类型必须为左值。
引用的对象在函数返回时不会超出范围。

就像通过引用向函数传递大型对象更有效的方式一样，通过引用从函数返回大型对象也可能更有效。 引用返回使得不必在返回前将对象复制到临时位置。

当函数的计算结果必须为左值时，引用返回类型也可能很有用。 大多数重载运算符属于此类别，尤其是赋值运算符。

## 异常处理

通常使用try,throw和catch处理异常，方式与C++相同。

## 断言和用户提供的消息

软件断言指定在程序的某个特定点应满足的条件。 如果编译时断言失败，编译器将发出诊断消息和编译错误。 如果运行时断言失败，操作系统将发出诊断消息并关闭应用程序。

-#Error 指令在预处理时有效。 它将无条件地发出用户指定的消息并导致编译因错误而失败。 该消息可包含由预处理器指令操作的文本，但不会计算任何生成的表达式。

-Static_assert声明在编译时有效。 它将测试由用户指定且可以转换为布尔值的整数表达式表示的软件断言。 如果表达式的计算结果为零 (false)，编译器将发出用户指定的消息，并且编译因错误而失败。

-断言宏 _assert，_wassert宏在运行时生效。 它会计算用户指定的表达式，如果结果为零，系统将发出诊断消息并关闭应用程序。 许多其他宏（如`_ASSERT`和`_ASSERTE`）都与此宏类似，但会发出不同的系统定义或用户定义的诊断消息。

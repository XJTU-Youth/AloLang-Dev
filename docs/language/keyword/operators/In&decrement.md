# 自修改运算符

自修改运算符可以修改对象的值

| 运算符名 | 语法  | 可重载 | 原型示例 | 原型示例 |
| :------: | :---: | :----: | :------: | :------: |
|          |       |        | 类内定义 | 类外定义 |
|  前自增  | `++a` |   是   |          |          |
|  前自减  | `--a` |   是   |          |          |
|  后自增  | `a++` |   是   |          |          |
|  后自减  | `a--` |   是   |          |          |

注解：对于任意一个二元运算符”(T)“，“(T)=”均为不可重载的自修改运算符。

## 解释

 前自增 与 前自减 运算符增加或减小对象的值，并返回到其结果的引用。

后自增 与 后自减 创建对象的副本，增加或减小对象的值，并返回自增或自减前的副本。

## 前置运算符

对于非布尔操作数$x$，表达式$++x$严格等价于$x+=1$，表达式$--x$严格等价于$x-=1$

若其中的$x$为bool类型,则操作无效。

## 后置运算符

内建后置自增或自减运算符的操作数表达式必须是非布尔的算术类型或指向完整定义的对象类型的指针类型的可修改左值。结果是操作数原值的纯右值副本。

若操做数位布尔类型，则操作无效。

## 示例

```
main() -> int 
{
    int n1 = 1;
    int n2 = ++n1;
    int n3 = ++(++n1);
    int n4 = n1++;
	output(stdout)({"n1 = ",n1,"\n"});
    output(stdout)({"n2 = ",n2,"\n"});
    output(stdout)({"n3 = ",n3,"\n"});
    output(stdout)({"n4 = ",n4,"\n"});
}
```

输出：

```
n1 = 5
n2 = 2
n3 = 4
n4 = 4
```

## 警告

严禁在同一个计算语句中出现可能导致不同结果的对同一个变量的多次自修改操作。

### 示例

```
int a=1;

/*以下每行中的操作都是编译器禁止的*/
int a1=(a++)*(++a)*(a++)*(++a);
int a2=(a-=1)*(a+=1)*(a*=2)+(a/=2);
int a3,a4;a3,a4=a++,++a;
//值得注意的是，","并不表示逗号运算符，而是元组的标志，因此不同于C语言，这行代码并不合法

/*以下每行的操作没有任何问题，并且可以得到正确结果*/
int a5=(a+=0)+(a-=0)*(a*=1)*(a/=1);//a3=2
int a6=++(++a);//a6=3

/*以下操作会因符号无法匹配而编译错误*/
int a7=a+++++++++;
int a8=++ ++ ++ ++ a;
//上面这行代码在C中是合法的，但在alolang中，应该表示为a8=++(++(++(++a)));
int a9=a++ + ++a;
```

